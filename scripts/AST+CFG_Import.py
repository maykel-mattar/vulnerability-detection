from neo4j import GraphDatabase
import json
import re
import time
import sys
from alive_progress import alive_bar


class MixedCreator:

    def __init__(self, uri):
        self.driver = GraphDatabase.driver(uri,database='astcfg')

    def close(self):
        self.driver.close()
    def run_delete(self):
        with self.driver.session() as session:
            delete = session.write_transaction(self._delete)
            return delete
    def run_create(self, node):
        with self.driver.session() as session:
            nodes = session.write_transaction(self._creat_nodes, node)
            return nodes

    def run_link(self, edge):
        with self.driver.session() as session:
            edges = session.write_transaction(self._link_nodes, edge)
            return edges
    def run_linkCFG(self, edge):
        with self.driver.session() as session:
            edges = session.write_transaction(self._link_cfg, edge)
            return edges
    def run_flows(self, node):
        with self.driver.session() as session:
            flows = session.write_transaction(self._flows_nodes, node)
            return flows
    @staticmethod
    def _delete(tx):
        query = "MATCH (n) DETACH DELETE n;"
        result = tx.run(query)
        return 'success'
    @staticmethod
    def _creat_nodes(tx, node):
        typeOfNode = "Statement"
        if node["type"] != "":
            typeOfNode = node["type"].replace('-','_')

        nodeString = json.dumps(node)
        nodeString = re.sub(r'"([^"]+)":', r'\1:', nodeString)
        query = "MERGE (a:" + typeOfNode + nodeString + ") RETURN  'success' "
        result = tx.run(query)
        return result.single()[0]

    @staticmethod
    def _link_nodes(tx, edge):
        typeOfEdge = "GO_TO"
        if edge["label"] != "":
            typeOfEdge = edge["label"].replace('-','_')
        source = edge["source"]
        target = edge["target"]
        query = " MATCH (a), (b) WHERE not a:CFG_Node and NOT a:PDG_DATA_Node and not b:CFG_Node and NOT b:PDG_DATA_Node AND a.id =" + str(
            source) + " AND b.id = " + str(target) + " MERGE (a)-[r:" + typeOfEdge + "]->(b) RETURN 'success' "
        result = tx.run(query)
        return result.single()[0]
    @staticmethod
    def _link_cfg(tx, edge):
        typeOfEdge="Simple"
        if edge["label"]!="":
            typeOfEdge=edge["label"]
        source = edge["source"]
        target = edge["target"]
        merginQuery=""
        if typeOfEdge == 'Simple':
            query = " Optional MATch (t{line:" + str(target) + "}) WHERE not t:BLOCK and NOT t:THEN and NOT t:ELSE Optional MATCH (s{line:"+str(source)+"}) WHERE not s:BLOCK and NOT s:THEN and NOT s:ELSE  with max(s.id) as source,min(t.id) as target MATCH (s{id:source}),(t{id:target})  MERGE (s)-[r:" + typeOfEdge + "]->(t) RETURN 'success' "
            result = tx.run(query)
            return result.single()[0]
        else:
            query1=" Optional MATCH (s{line:"+str(source)+"})  WHERE s:CASE or s:COND with max(s.id) as source MATCH (s{id:source})  return labels(s)[0],s.id"
            result = tx.run(query1)
            conditionNode=result.single()
            if conditionNode:
                if typeOfEdge=="True":
                    sourceID = conditionNode[1]
                    SourceType=conditionNode[0]
                    if SourceType=="CASE":
                        query1 = "  MATCH (s{id:" + str(sourceID + -1) + "})   return labels(s)[0],s.id"
                    else:
                        query1 = "  MATCH (s{id:" + str(sourceID+1) + "})   return labels(s)[0],s.id"
                    result = tx.run(query1)
                    destinationNode = result.single()
                    if destinationNode[0]=="UPDATE": #In case of for
                        query1 = "  MATCH (s{id:" + str(destinationNode[1] + 2) + "})   return labels(s)[0],s.id"
                        result = tx.run(query1)
                        t4Result = result.single()
                        if t4Result:
                            query = " MATCH (n{id:"+str(t4Result[1])+"})-[:GO_TO]->(t),(f{id:"+str(conditionNode[1])+"}) MERGE (f)-[r:" + typeOfEdge + "]->(t) Return DISTINCT 'success' "

                            result1 = tx.run(query) #child

                            query = " MATCH (n{id:"+str(destinationNode[1]) +"}) ,(f{id:"+str(conditionNode[1])+"}) MERGE (f)-[r:" + typeOfEdge + "]->(n) Return DISTINCT 'success' "
                            result2 = tx.run(query)
                            if result1.single()[0]=='success' and result2.single()[0]=='success':
                                return 'success'
                            else:
                                return 'Failed'
                        else:
                            return 'Failed'
                    else:
                        query = " MATCH (n{id:" + str(destinationNode[1]) + "})-[:GO_TO]->(t),(f{id:" + str(conditionNode[1]) + "}) MERGE (f)-[r:" + typeOfEdge + "]->(t) Return DISTINCT 'success' "
                        result1 = tx.run(query)
                        return result1.single()[0]
                else:
                    query1 = "  MATCH (s{line:" + str(target) + "})   return labels(s)[0],s.id"
                    result = tx.run(query1)
                    t4Result = result.single()
                    if t4Result:
                        if t4Result[0] == "Statement":
                            query1 = "  MATCH (s{line:" + str(target-1) + "})   return labels(s)[0],s.id"
                            result = tx.run(query1)
                            t4Result = result.single()
                            query = " MATCH (n{id:" + str(t4Result[1]) + "})-[:GO_TO]->(t),(f{id:" + str(
                                conditionNode[1]) + "}) MERGE (f)-[r:" + typeOfEdge + "]->(t) Return DISTINCT 'success' "

                            result1 = tx.run(query)

                            return result1.single()[0]
                        else:
                            query = " MATCH (n{id:" + str(t4Result[1]) + "}) ,(f{id:" + str(conditionNode[1]) + "}) MERGE (f)-[r:" + typeOfEdge + "]->(n) Return DISTINCT 'success' "
                            result2 = tx.run(query)
                            return result2.single()[0]
                    else:
                            return 'Failed'

    @staticmethod
    def _flows_nodes(tx, node):
        label = node['label']
        method = node['method']
        typeOfEdge = "flows{label:'"+label+"',method:'"+method+"'}"
        source = node["source"]
        target = node["target"]
        query = " MATCH (a), (b) WHERE not a:CFG_Node and NOT a:PDG_DATA_Node and not b:CFG_Node and NOT b:PDG_DATA_Node AND a.id =" + str(
            source) + " AND b.id = " + str(target) + " MERGE (a)-[r:" + typeOfEdge + "]->(b) Return DISTINCT 'success' "
        result = tx.run(query)
        return result.single()[0]

if __name__ == "__main__":
    Mixed = MixedCreator("bolt://neo4j:7687")
    f = open(sys.argv[2], )
    cfgData= json.load(f)
    f.close()
    f = open(sys.argv[1], )
    data = json.load(f)
    f.close()
    insertError = 0
    insertSucced = 0
    linkError = 0
    linkSucced = 0
    CFGlinkError=0
    CFGlinkSucced=0
    normalized = [x for x in data['nodes'] if x['label'] != x['normalized']]

    processlength = len(data['nodes']) + len(data['edges'])+len(normalized)+len(cfgData['edges'])
    Mixed.run_delete()
    with alive_bar(processlength, title="Mixed Import") as bar:
        for i in data['nodes']:
            i['typeInt'] = ''.join(str(ord(c)) for c in i['type'])
            i['labelInt'] = ''.join(str(ord(c)) for c in i['label'])
            time.sleep(0.002)
            bar()
            creator = Mixed.run_create(i)
            if creator != "success":
                insertError += 1
            else:
                insertSucced += 1

        for j in data['edges']:
            time.sleep(0.002)
            bar()
            linker = Mixed.run_link(j)
            if linker != "success":
                linkError += 1
            else:
                linkSucced += 1

        linked = []
        methods=[x['id'] for x in data['nodes'] if '$METHOD' in x['normalized']]
        methodsName= [x['label'] for x in data['nodes'] if '$METHOD' in x['normalized']]
        count=0
        nodesData=data['nodes']
        currentMethod="ROOT"
        for j in normalized:
            time.sleep(0.002)
            bar()
            if '$METHOD' in j['normalized']:
                linked=[]
                if count+1==len(methods):
                    nodesData = [x for x in data['nodes'] if x['id'] > methods[count]]
                else:
                    nodesData=[x for x in data['nodes'] if x['id']>methods[count] and x['id']<methods[count+1] ]
                currentMethod=methodsName[count]
                count += 1
                continue
        # Closing file
        edgesLine = []
        for j in cfgData['edges']:
            source = [x['line'] for x in cfgData['nodes'] if x['id'] == j['source']][0]
            target = [x['line'] for x in cfgData['nodes'] if x['id'] == j['target']][0]
            label = j['label']
            time.sleep(0.002)
            bar()
            if source>0 and target>0:
                CFGlinker = Mixed.run_linkCFG({'source':source,'target':target,'label':label})
            if CFGlinker != "success":
                CFGlinkError += 1
            else:
                CFGlinkSucced += 1
    if insertError > 0:
        print(str(insertError) + " Nodes Failed to insert")
    print(str(insertSucced) + " Nodes are inserted")
    if linkError > 0:
        print(str(insertError) + " Relations Failed to insert")
    print(str(linkSucced) + " Relations are inserted")
    if CFGlinkError > 0:
        print(str(CFGlinkError) + " Controls Failed to insert")
    print(str(CFGlinkSucced) + " Controls are inserted")
    Mixed.close()
